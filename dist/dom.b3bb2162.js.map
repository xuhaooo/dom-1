{"version":3,"sources":["dom.js"],"names":["window","log","console","bind","dom","create","string","container","document","createElement","innerHTML","trim","content","firstChild","after","node","node2","parentNode","insertBefore","nextSibling","before","append","parent","appendChild","wrap","remove","removeChild","empty","x","array","push","attr","name","value","arguments","length","setAttribute","getAttribute","text","innerText","textContent","html","style","Object","object","key","class","add","className","classList","has","contains","on","eventName","fn","addEventListener","off","removeEventListener","find","selector","scope","querySelectorAll","children","siblings","Array","from","filter","n","next","nodeType","previous","previousSibling","each","nodeList","i","call","index","childrenList"],"mappings":"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","file":"dom.b3bb2162.js","sourceRoot":"../src","sourcesContent":["window.log = console.log.bind(console)\n\n// dom.create = function(){};\n// 当然可以直接写在 dom 里面如下\nwindow.dom = {\n    // create: function () {}\n    // 当然也可以简化成下面\n\n    // 用于创建一个节点的 create\n    // 看一下功能，接收一个标签名，返回一个标签\n    create(string) {\n        // return document.createElement(tagName)\n        const container = document.createElement(\"template\")\n        container.innerHTML = string.trim()\n        return container.content.firstChild\n    },\n    // 在 main.js 里面试一下\n\n    // 用于新增一个弟弟的 after\n    // 参数：在哪个节点后面加，加什么节点\n    after(node, node2) {\n        // 很遗憾搜不到 insertAfter 这样的接口，只有 insertBefore\n        // 搜到的 ChildNode.after() 这个接口兼容性不好，是实验性的接口\n        // 再搜，想一下，想在 node 后面加，是不是就是在 node 后面的节点的前面加，于是\n        node.parentNode.insertBefore(node2, node.nextSibling)\n        // 试一下，可以把 newDiv 加到了 test 之后\n        // 总结一下，想放到 node 后面，就找到 node 的爸爸，然后调用它的 insertBefore，把 node2 插到了 node 的下个节点的前面去\n        // 为什么这么长这么复杂呢，dom 就是这么反人类，你用必须还有封装一下\n        // node 如果是最后一个节点，那它的下个节点就是回车，但如果修改一下把标签都凑到一块，会发现 node 最后一个节点是 null，但还是可以插到 node 后面去\n    },\n\n    // 用于新增一个哥哥的 before\n    before(node, node2) {\n        node.parentNode.insertBefore(node2, node)\n        // 简单，可以直接用 insertBefore\n    },\n\n    // 用于新增儿子的 append\n    // 接收爸爸和儿子\n    append(parent, node) {\n        parent.appendChild(node)\n    },\n\n    // 用于新增一个爸爸的 wrap\n    wrap(node, parent) {\n        dom.before(node, parent)\n        dom.append(parent, node)\n        // 看不懂吧，解释一下，比如 dom.wrap(div2, div3)\n        // 比如 div1 > div2，我想要 div1 > div3 > div2\n        // 怎么弄呢，我先在 div2 前新增 div3 哥哥，div1 > div3+div2，事实上新增成弟弟也没事\n        // 然后，在 div3 里面新增儿子 div2，即把 div2 append 到 div3 里面\n        // append 这个 API 使用过后之前的位置就没了，div2 直接到 div3 里面了\n    },\n    // 以上，”增“已经搞完了\n    // 看起来几个简单的 API，里面确实肮脏的实现\n\n    // --- 分割线 ---\n\n    // 用于删除节点\n    remove(node) {\n        // 让这个节点的爸爸删除它自己的这个儿子节点\n        node.parentNode.removeChild(node)\n        // 在树中删了，return 一下，这样删的人还可以保留这个节点的引用\n        return node \n    },\n\n    // 用于删除该节点所有儿子节点\n    empty(node) {\n        // 虽然可以通过 node.innerHTML = '' 做，但是想要删掉的所有子节点的引用怎么办呢，就是说返回移除的对象，所以\n        // const childNodes = node.childNodes\n        // 用高级语法，记住这个能简写就行了\n        // const {childNodes} = node\n        const array = []\n        // for (let i = 0; i < childNodes.length; i++) {\n        //     // console.log(childNodes.length)，还记得之前说过吗，childNodes 的 length 会动态变化的，而我们以为它一直是那几个节点\n        //     dom.remove(childNodes[i])\n        //     array.push(childNodes[i])\n        //     // array.push(dom.remove(childNodes[i]))，打印出来全是 text 节点，所以做上面注释的操作\n        //     // 那怎么办呢，当 remove 之后 i 就不再是小于 7，而是小于 6 了，i 是不需要加的，所以不适合用 for 循环做\n        // }\n        // return array\n\n        // 用 while 循环做\n        // 我们要把所有的元素删掉，那我们先找到它的第一个儿子，如果存在就移除它，然后放入数组中\n        // 然后再把 x 指向它的 firstChild（大儿子）\n        // 迷惑？每次都是删除大儿子，然后用 x 指向新的大儿子（原来的二儿子）\n        let x = node.firstChild\n        while(x){\n            array.push(dom.remove(node.firstChild))\n            x = node.firstChild\n        }\n        return array\n    },\n    // OK，”删“搞定了\n\n    // 好，接下来做”改\"\n    // 用于给元素“读写”属性的 attr\n    attr(node, name, value) {\n        // node.setAttribute(name, value)\n        // 测试一个可以写属性了，那读取怎么弄，即 const title = dom.attr(node, name)\n        // 不对啊，实现的时候是 3 个参数这里怎么可以只传 2 个参数呢\n        // JS 的函数是可以接受多种参数的\n        // 实现就是，在这里判断一下，3 个就设置，2 个就获取并返回\n        // 如果长度为 3 就 set，如果长度为 2 就 get，这种小技巧叫重载\n        // 先记住，根据参数的个数写不同的代码就是重载，JS 里只能这样重载\n        if(arguments.length === 3){\n            node.setAttribute(name, value)\n        } else if(arguments.length === 2){\n            return node.getAttribute(name)\n        }\n    },\n\n    // 设置元素的文本内容\n    text(node, string) {\n        // node.innerText = string\n        // 有一个问题，比如文本里面有标签，这么设置的话标签就没有了，比如“前面的文本<p>hi</p>后面的文本”，p 标签没有了\n        // 但是这个是写库的人也没办法的事情，你就不能用 <span> 把“前面的文本“包起来，然后再改吗；于是就用这么粗暴的方式，使用者根据现象来自己调整使用\n        // 那为什么不用 node.textContent = string 呢，因为上面是旧 ie，下面的是 firefox/chrome，所有的浏览器基本都支持两种，为了让代码在所有浏览器上都能跑，用上面的那种，但所以最好还是判断一下\n        // 这种写代码的方法，就叫适配，110V 220V 都能转成 5V2A\n        // 根据上面的经验，如果需要获取怎么办，所以还是要判断参数\n        if(arguments.length === 2){\n            if('innerText' in node){\n                node.innerText = string\n            }else{\n                node.textContent = string\n            }\n        }else if(arguments.length === 1){\n            if('innerText' in node){\n                return node.innerText\n            }else{\n                return node.textContent\n            }\n        }\n    },\n\n    // 读写 HTML 内容的 html\n    html(node, string) {\n        // 又一次用到了重载\n        if(arguments.length === 2){\n            node.innerHTML = string\n        }else if(arguments.length === 1){\n            return node.innerHTML\n        }\n    },\n\n    // 用于修改 style 属性\n    // style(node, object) {\n    //     for(let key in object){\n    //         node.style[key] = object[key]\n    //         // 因为 object 里面的 key 可能是 border/color\n    //         // 正常代码应该是 node.style.border = .../node.style.color = ...\n    //         // 但是现在 border、color 都是不确定的是变量，如果你用变量作为 key 的话，必须放在 [] 里，用 . （node.style.key）就会变成字符串，之前讲过\n    //     }\n    // }\n    // 还是要分情况\n    style(node, name, value) {\n        if (arguments.length === 3) {\n            // style(div, 'color', 'red')\n            node.style[name] = value\n        } else if(arguments.length === 2) {\n            if(typeof name === 'string'){ // 注意判断方式\n                // dom.style(div, 'color')\n                return node.style[name]\n            } else if(name instanceof Object) { // 注意这里的判断方式\n                // dom.style(div, {color: 'red'})\n                const object = name // 别名替换，看着不难受\n                for(let key in object){\n                    node.style[key] = object[key]\n                }\n            }\n        }\n    },\n    // 难吗？不是很难吧，可以看到程序员在工作中的不在于什么算法数据结构，把需求理清楚，然后用最基本的语法把它搞定就行了\n\n    class: {\n        // 继续，用于添加 class 的 class.add\n        add(node, className) {\n            node.classList.add(className)\n        },\n        // 用于删除 class 的 class.remove\n        remove(node, className) {\n            node.classList.remove(className)\n        },\n        // 用于判断有没有 class 的 class.has\n        has(node, className) {\n            return node.classList.contains(className) // 记住要 return\n        },\n    },\n\n    // 用于添加事件监听的 on\n    // 之间添加是这样的，test.addEventListener('click')\n    on(node, eventName, fn) {\n        node.addEventListener(eventName, fn)\n    },\n\n    // 用于移除事件监听的 off\n    off(node, eventName, fn) {\n        node.removeEventListener(eventName, fn)\n    },\n\n    // OK，”改“搞定了\n    // --- 分割线 ---\n    // 继续，实现”查“，之前我们都是用全局属性，test\n\n    // 用于获取标签或标签们的 find\n    find(selector, scope) {\n        // return document.querySelectorAll(selector)\n        // 不管你给的选择器是一个元素还是有多个元素，我全部都返回 all，也就说返回一个数组\n\n        return (scope || document).querySelectorAll(selector)\n        // 即，如果有 scope 我就在 scope 里面 queryS；如果没有 scope 我就在 document 里面来 queryS\n        // 当然你也可以用一个中间变量，const x = scope || document;s.queryS;但是高手写代码写多了根本不会这么写\n    },\n\n    // 用于获取父元素的 parent\n    parent(node) {\n        return node.parentNode\n    },\n\n    // 用于获取子元素的 children\n    children(node) {\n        return node.children\n    },\n\n    // 用于获取兄弟姐妹的 siblings\n    siblings(node) {\n        return Array.from(node.parentNode.children).filter(n=>n!==node)\n        // 记得吗，兄弟姐妹是不包括自己的\n        // 用 filter（node.parentNode.children.filter）不行吗？不行，因为 node.parentNode.children 不是数组，是伪数组啊，得变成数组才行\n        // 变成数组过后进行过滤，只要元素不等于当前节点，就放到这个数组里面\n    },\n\n    // 用于获取弟弟 next\n    next(node) {\n        // return node.nextSibling\n        // 这样可以吗？可能是错的，因为可能会返回文本节点，所以需要判断\n        let x = node.nextSibling\n        while(x && x.nodeType === 3){\n            x = x.nextSibling\n        }\n        return x\n        // 如果 x 存在，就判断它是不是文本节点，如果是那就把它下一个节点给它，再判断，如果还是文本节点，再下一个，如果是空呢，那没得办法了，也得返回\n    },\n\n    // 用于获取哥哥的 previous，代码一样的，改成 previous 而已\n    previous(node) {\n        let x = node.previousSibling\n        while(x && x.nodeType === 3){\n            x = x.previousSibling\n        }\n        return x\n    },\n\n    // 用于遍历所有节点的 each\n    each(nodeList, fn) {\n        for(let i=0;i<nodeList.length;i++){\n            fn.call(null, nodeList[i])\n        }\n    },\n\n    // 用于获取一个元素排行老几的 index\n    // 目前还不知道，你得问它的爸爸才能知道啊\n    index(node) {\n        // 不能直接用 node.parentNode.children 因为这个 children 是会变的\n        const childrenList = dom.children(node.parentNode)\n        let i\n        for(i=0;i<childrenList.length;i++){\n            if(childrenList[i] === node){\n                break\n                // 看每个孩子是否等于当前元素，那就别动了，返回 i\n            }\n        }\n        return i // 合并报错 i 没有定义，因为 for 里面 let i 只在里面有效，return 拿不到，把 let 拿出去\n    }\n}\n"]}