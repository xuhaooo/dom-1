{"version":3,"sources":["dom.js"],"names":["window","log","console","bind","dom","create","string","container","document","createElement","innerHTML","trim","content","firstChild","after","node","node2","parentNode","insertBefore","nextSibling","before","append","parent","appendChild","wrap","remove","removeChild","empty","array","x","push","attr","name","value","arguments","length","setAttribute","getAttribute","text","innerText","textContent","html","style","Object","object","key","class","add","className","classList","has","contains","on","eventName","fn","addEventListener","off","removeEventListener","find","selector","scope","querySelectorAll","children","siblings","Array","from","filter","n","next","nodeType","previous","previousSibling","each","nodeList","i","call","index","childrenList"],"mappings":"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","file":"dom.1d0b6d56.js","sourceRoot":"../src","sourcesContent":["window.log = console.log.bind(console)\n\n// dom.create = function(){};\n// 当然可以直接写在 dom 里面如下\nwindow.dom = {\n    // create: function () {}\n    // 当然也可以简化成下面\n\n    // 用于创建一个节点的 create\n    // 看一下功能，接收一个标签名，返回一个标签\n    create(string) {\n        // return document.createElement(tagName)\n        const container = document.createElement(\"template\")\n        container.innerHTML = string.trim()\n        return container.content.firstChild\n    },\n    // 在 main.js 里面试一下\n\n    // 用于新增一个弟弟的 after\n    // 参数：在哪个节点后面加，加什么节点\n    after(node, node2) {\n        // 很遗憾搜不到 insertAfter 这样的接口，只有 insertBefore\n        // 搜到的 ChildNode.after() 这个接口兼容性不好，是实验性的接口\n        // 再搜，想一下，想在 node 后面加，是不是就是在 node 后面的节点的前面加，于是\n        node.parentNode.insertBefore(node2, node.nextSibling)\n        // 试一下，可以把 newDiv 加到了 test 之后\n        // 总结一下，想放到 node 后面，就找到 node 的爸爸，然后调用它的 insertBefore，把 node2 插到了 node 的下个节点的前面去\n        // 为什么这么长这么复杂呢，dom 就是这么反人类，你用必须还有封装一下\n        // node 如果是最后一个节点，那它的下个节点就是回车，但如果修改一下把标签都凑到一块，会发现 node 最后一个节点是 null，但还是可以插到 node 后面去\n    },\n\n    // 用于新增一个哥哥的 before\n    before(node, node2) {\n        node.parentNode.insertBefore(node2, node)\n        // 简单，可以直接用 insertBefore\n    },\n\n    // 用于新增儿子的 append\n    // 接收爸爸和儿子\n    append(parent, node) {\n        parent.appendChild(node)\n    },\n\n    // 用于新增一个爸爸的 wrap\n    wrap(node, parent) {\n        dom.before(node, parent)\n        dom.append(parent, node)\n        // 看不懂吧，解释一下，比如 dom.wrap(div2, div3)\n        // 比如 div1 > div2，我想要 div1 > div3 > div2\n        // 怎么弄呢，我先在 div2 前新增 div3 哥哥，div1 > div3+div2，事实上新增成弟弟也没事\n        // 然后，在 div3 里面新增儿子 div2，即把 div2 append 到 div3 里面\n        // append 这个 API 使用过后之前的位置就没了，div2 直接到 div3 里面了\n    },\n    // 以上，”增“已经搞完了\n    // 看起来几个简单的 API，里面确实肮脏的实现\n\n    // --- 分割线 ---\n\n    // 用于删除节点\n    remove(node) {\n        // 让这个节点的爸爸删除它自己的这个儿子节点\n        node.parentNode.removeChild(node)\n        // 在树中删了，return 一下，这样删的人还可以保留这个节点的引用\n        return node \n    },\n\n    // 用于删除该节点所有儿子节点\n    empty(node) {\n        // 虽然可以通过 node.innerHTML = '' 做，但是想要删掉的所有子节点的引用怎么办呢，就是说返回移除的对象，所以\n        // const childNodes = node.childNodes\n        // 用高级语法，记住这个能简写就行了\n        // const {childNodes} = node\n        const array = []\n        // for (let i = 0; i < childNodes.length; i++) {\n        //     // console.log(childNodes.length)，还记得之前说过吗，childNodes 的 length 会动态变化的，而我们以为它一直是那几个节点\n        //     dom.remove(childNodes[i])\n        //     array.push(childNodes[i])\n        //     // array.push(dom.remove(childNodes[i]))，打印出来全是 text 节点，所以做上面注释的操作\n        //     // 那怎么办呢，当 remove 之后 i 就不再是小于 7，而是小于 6 了，i 是不需要加的，所以不适合用 for 循环做\n        // }\n        // return array\n\n        // 用 while 循环做\n        // 我们要把所有的元素删掉，那我们先找到它的第一个儿子，如果存在就移除它，然后放入数组中\n        // 然后再把 x 指向它的 firstChild（大儿子）\n        // 迷惑？每次都是删除大儿子，然后用 x 指向新的大儿子（原来的二儿子）\n        let x = node.firstChild\n        while(x){\n            array.push(dom.remove(node.firstChild))\n            x = node.firstChild\n        }\n        return array\n    },\n    // OK，”删“搞定了\n\n    // 好，接下来做”改\"\n    // 用于给元素“读写”属性的 attr\n    attr(node, name, value) {\n        // node.setAttribute(name, value)\n        // 测试一个可以写属性了，那读取怎么弄，即 const title = dom.attr(node, name)\n        // 不对啊，实现的时候是 3 个参数这里怎么可以只传 2 个参数呢\n        // JS 的函数是可以接受多种参数的\n        // 实现就是，在这里判断一下，3 个就设置，2 个就获取并返回\n        // 如果长度为 3 就 set，如果长度为 2 就 get，这种小技巧叫重载\n        // 先记住，根据参数的个数写不同的代码就是重载，JS 里只能这样重载\n        if(arguments.length === 3){\n            node.setAttribute(name, value)\n        } else if(arguments.length === 2){\n            return node.getAttribute(name)\n        }\n    },\n\n    // 设置元素的文本内容\n    text(node, string) {\n        // node.innerText = string\n        // 有一个问题，比如文本里面有标签，这么设置的话标签就没有了，比如“前面的文本<p>hi</p>后面的文本”，p 标签没有了\n        // 但是这个是写库的人也没办法的事情，你就不能用 <span> 把“前面的文本“包起来，然后再改吗；于是就用这么粗暴的方式，使用者根据现象来自己调整使用\n        // 那为什么不用 node.textContent = string 呢，因为上面是旧 ie，下面的是 firefox/chrome，所有的浏览器基本都支持两种，为了让代码在所有浏览器上都能跑，用上面的那种，但所以最好还是判断一下\n        // 这种写代码的方法，就叫适配，110V 220V 都能转成 5V2A\n        // 根据上面的经验，如果需要获取怎么办，所以还是要判断参数\n        if(arguments.length === 2){\n            if('innerText' in node){\n                node.innerText = string\n            }else{\n                node.textContent = string\n            }\n        }else if(arguments.length === 1){\n            if('innerText' in node){\n                return node.innerText\n            }else{\n                return node.textContent\n            }\n        }\n    },\n\n    // 读写 HTML 内容的 html\n    html(node, string) {\n        // 又一次用到了重载\n        if(arguments.length === 2){\n            node.innerHTML = string\n        }else if(arguments.length === 1){\n            return node.innerHTML\n        }\n    },\n\n    // 用于修改 style 属性\n    // style(node, object) {\n    //     for(let key in object){\n    //         node.style[key] = object[key]\n    //         // 因为 object 里面的 key 可能是 border/color\n    //         // 正常代码应该是 node.style.border = .../node.style.color = ...\n    //         // 但是现在 border、color 都是不确定的是变量，如果你用变量作为 key 的话，必须放在 [] 里，用 . （node.style.key）就会变成字符串，之前讲过\n    //     }\n    // }\n    // 还是要分情况\n    style(node, name, value) {\n        if (arguments.length === 3) {\n            // style(div, 'color', 'red')\n            node.style[name] = value\n        } else if(arguments.length === 2) {\n            if(typeof name === 'string'){ // 注意判断方式\n                // dom.style(div, 'color')\n                return node.style[name]\n            } else if(name instanceof Object) { // 注意这里的判断方式\n                // dom.style(div, {color: 'red'})\n                const object = name // 别名替换，看着不难受\n                for(let key in object){\n                    node.style[key] = object[key]\n                }\n            }\n        }\n    },\n    // 难吗？不是很难吧，可以看到程序员在工作中的不在于什么算法数据结构，把需求理清楚，然后用最基本的语法把它搞定就行了\n\n    class: {\n        // 继续，用于添加 class 的 class.add\n        add(node, className) {\n            node.classList.add(className)\n        },\n        // 用于删除 class 的 class.remove\n        remove(node, className) {\n            node.classList.remove(className)\n        },\n        // 用于判断有没有 class 的 class.has\n        has(node, className) {\n            return node.classList.contains(className) // 记住要 return\n        },\n    },\n\n    // 用于添加事件监听的 on\n    // 之间添加是这样的，test.addEventListener('click')\n    on(node, eventName, fn) {\n        node.addEventListener(eventName, fn)\n    },\n\n    // 用于移除事件监听的 off\n    off(node, eventName, fn) {\n        node.removeEventListener(eventName, fn)\n    },\n\n    // OK，”改“搞定了\n    // --- 分割线 ---\n    // 继续，实现”查“，之前我们都是用全局属性，test\n\n    // 用于获取标签或标签们的 find\n    find(selector, scope) {\n        // return document.querySelectorAll(selector)\n        // 不管你给的选择器是一个元素还是有多个元素，我全部都返回 all，也就说返回一个数组\n\n        return (scope || document).querySelectorAll(selector)\n        // 即，如果有 scope 我就在 scope 里面 queryS；如果没有 scope 我就在 document 里面来 queryS\n        // 当然你也可以用一个中间变量，const x = scope || document;s.queryS;但是高手写代码写多了根本不会这么写\n    },\n\n    // 用于获取父元素的 parent\n    parent(node) {\n        return node.parentNode\n    },\n\n    // 用于获取子元素的 children\n    children(node) {\n        return node.children\n    },\n\n    // 用于获取兄弟姐妹的 siblings\n    siblings(node) {\n        return Array.from(node.parentNode.children).filter(n=>n!==node)\n        // 记得吗，兄弟姐妹是不包括自己的\n        // 用 filter（node.parentNode.children.filter）不行吗？不行，因为 node.parentNode.children 不是数组，是伪数组啊，得变成数组才行\n        // 变成数组过后进行过滤，只要元素不等于当前节点，就放到这个数组里面\n    },\n\n    // 用于获取弟弟 next\n    next(node) {\n        // return node.nextSibling\n        // 这样可以吗？可能是错的，因为可能会返回文本节点，所以需要判断\n        let x = node.nextSibling\n        while(x && x.nodeType === 3){\n            x = x.nextSibling\n        }\n        return x\n        // 如果 x 存在，就判断它是不是文本节点，如果是那就把它下一个节点给它，再判断，如果还是文本节点，再下一个，如果是空呢，那没得办法了，也得返回\n    },\n\n    // 用于获取哥哥的 previous，代码一样的，改成 previous 而已\n    previous(node) {\n        let x = node.previousSibling\n        while(x && x.nodeType === 3){\n            x = x.previousSibling\n        }\n        return x\n    },\n\n    // 用于遍历所有节点的 each\n    each(nodeList, fn) {\n        for(let i=0;i<nodeList.length;i++){\n            fn.call(null, nodeList[i])\n        }\n    },\n\n    // 用于获取一个元素排行老几的 index\n    // 目前还不知道，你得问它的爸爸才能知道啊\n    index(node) {\n        // 不能直接用 node.parentNode.children 因为这个 children 是会变的\n        const childrenList = dom.children(node.parentNode)\n        let i\n        for(i=0;i<childrenList.length;i++){\n            if(childrenList[i] === node){\n                break\n                // 看每个孩子是否等于当前元素，那就别动了，返回 i\n            }\n        }\n        return i // 合并报错 i 没有定义，因为 for 里面 let i 只在里面有效，return 拿不到，把 let 拿出去\n    }\n}\n"]}